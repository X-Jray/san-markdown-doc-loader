{"version":3,"sources":["markdown-it-plugin/fence.js"],"names":["DEFAULT_OPTIONS","validate","defaultValidate","render","defaultRender","marker","params","trim","split","name","tokens","idx","options","env","self","nesting","attrPush","renderToken","MARKER_LEN","module","exports","md","Object","assign","fence","state","startLine","endLine","silent","begin","bMarks","tShift","end","eMarks","haveEndMarker","sCount","blkIndent","i","src","charAt","markup","slice","indexOf","nextLine","mem","skipChars","charCodeAt","skipSpaces","line","token","push","info","content","getLines","map","block","ruler","before","alt","renderer","rules"],"mappings":"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","file":"fence.js","sourcesContent":["/**\n * @file 特殊的 Fence Block 处理\n * @author leon <ludafa@outlook.com>\n */\n\nconst DEFAULT_OPTIONS = {\n    validate: defaultValidate,\n    render: defaultRender,\n    marker: '`'\n};\n\nfunction defaultValidate(params) {\n    return params.trim().split(' ', 2)[0] === name;\n}\n\nfunction defaultRender(tokens, idx, options, env, self) {\n\n    if (tokens[idx].nesting === 1) {\n        tokens[idx].attrPush(['class', name]);\n    }\n\n    return self.renderToken(tokens, idx, options, env, self);\n\n}\n\nconst MARKER_LEN = 3;\n\nmodule.exports = function (md, name, options) {\n\n    let  {\n        validate,\n        render,\n        marker\n    } = Object.assign({}, DEFAULT_OPTIONS, options);\n\n    function fence(state, startLine, endLine, silent) {\n\n        let begin = state.bMarks[startLine] + state.tShift[startLine];\n        let end = state.eMarks[startLine];\n        let haveEndMarker = false;\n\n        if (\n            // if it's indented more than 3 spaces, it should be a code block\n            state.sCount[startLine] - state.blkIndent >= 4\n            // 此行没有至少 3 个字段\n            || begin + 3 > end\n        ) {\n            return false;\n        }\n\n        // 不是以 marker 开头\n        for (let i = 0; i < MARKER_LEN; i++) {\n            if (state.src.charAt(begin + i) !== marker) {\n                return false;\n            }\n        }\n\n        let markup = state.src.slice(begin, begin + MARKER_LEN);\n        let params = state.src.slice(begin + MARKER_LEN, end);\n\n        // 同一行里后边还有 marker，那这么这一行不是 fence\n        if (params.indexOf(marker) >= 0) {\n            return false;\n        }\n\n        // 校验不通过直接返回\n        if (!validate(params)) {\n            return false;\n        }\n\n        // 找到了 marker，且被标识为 silent 模式，那么只返回一个 true，表示当前块应该结束\n        if (silent) {\n            return true;\n        }\n\n        let nextLine = startLine + 1;\n\n        for (;nextLine <= endLine; nextLine++) {\n\n            let begin = state.bMarks[nextLine] + state.tShift[nextLine];\n            let end = state.eMarks[nextLine];\n            let mem = begin;\n\n            if (begin < end && state.sCount[nextLine] < state.blkIndent) {\n                break;\n            }\n\n            if (state.src.charAt(begin) !== marker) {\n                continue;\n            }\n\n            if (state.sCount[nextLine] - state.blkIndent >= 4) {\n                continue;\n            }\n\n            begin = state.skipChars(begin, marker.charCodeAt(0));\n\n            if (begin - mem < MARKER_LEN) {\n                continue;\n            }\n\n            begin = state.skipSpaces(begin);\n\n            if (begin < end) {\n                continue;\n            }\n\n            haveEndMarker = true;\n\n            break;\n\n        }\n\n        // 吃掉匹配到的 N 行\n        state.line = nextLine + (haveEndMarker ? 1 : 0);\n\n        let token = state.push(name, 'div', 0);\n\n        token.info = params;\n        token.content = state.getLines(\n            startLine + 1,\n            nextLine,\n            state.sCount[startLine],\n            true\n        );\n\n        token.markup = markup;\n        token.map = [startLine, state.line];\n\n        return true;\n\n    }\n\n    md.block.ruler.before(\n        'fence',\n        name,\n        fence,\n        {\n            alt: ['paragraph', 'reference', 'blockquote', 'list']\n        }\n    );\n\n    md.renderer.rules[name] = render;\n\n};\n"]}